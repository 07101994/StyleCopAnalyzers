// This file originally obtained from 
// https://raw.githubusercontent.com/code-cracker/code-cracker/08c1a01337964924eeed12be8b14c8ce8ec6b626/src/Common/CodeCracker.Common/Extensions/GeneratedCodeAnalysisExtensions.cs
// It is subject to the Apache License 2.0
// This file has been modified since obtaining it from its original source.

namespace StyleCop.Analyzers
{
    using System.Linq;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Diagnostics;

    internal static class GeneratedCodeAnalysisExtensions
    {
        internal static bool IsGenerated(this SyntaxNodeAnalysisContext context, CancellationToken cancellationToken) => (context.Node.SyntaxTree?.IsGenerated(cancellationToken) ?? false) || (context.Node?.IsGenerated() ?? false);

        internal static bool IsGenerated(this SyntaxTreeAnalysisContext context, CancellationToken cancellationToken) => context.Tree?.IsGenerated(cancellationToken) ?? false;

        internal static bool IsGenerated(this SymbolAnalysisContext context, CancellationToken cancellationToken)
        {
            if (context.Symbol == null) return false;
            foreach (var syntaxReference in context.Symbol.DeclaringSyntaxReferences)
            {
                if (syntaxReference.SyntaxTree.IsGenerated(cancellationToken)) return true;
                var root = syntaxReference.SyntaxTree.GetRoot(cancellationToken);
                var node = root?.FindNode(syntaxReference.Span);
                if (node.IsGenerated()) return true;
            }
            return false;
        }

        internal static bool IsGenerated(this SyntaxNode node) => node.HasAttributeOnAncestorOrSelf("DebuggerNonUserCode", "GeneratedCode");

        internal static bool IsGenerated(this SyntaxTree tree, CancellationToken cancellationToken) => (tree.FilePath?.IsOnGeneratedFile() ?? false) || tree.HasAutoGeneratedComment(cancellationToken);

        internal static bool HasAutoGeneratedComment(this SyntaxTree tree, CancellationToken cancellationToken)
        {
            var root = tree.GetRoot(cancellationToken);
            if (root == null) return false;
            var firstToken = root.GetFirstToken();
            SyntaxTriviaList trivia;
            if (firstToken == default(SyntaxToken))
            {
                var token = ((CompilationUnitSyntax)root).EndOfFileToken;
                if (!token.HasLeadingTrivia) return false;
                trivia = token.LeadingTrivia;
            }
            else
            {
                if (!firstToken.HasLeadingTrivia) return false;
                trivia = firstToken.LeadingTrivia;
            }

            var commentLines = trivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2).ToList();
            if (commentLines.Count != 2) return false;
            return commentLines[1].ToString() == "// <auto-generated>";
        }

        private static bool IsOnGeneratedFile(this string filePath) =>
            Regex.IsMatch(filePath, @"(^service|^TemporaryGeneratedFile_.*|^assemblyinfo|^assemblyattributes|\.(g\.i|g|designer|generated|assemblyattributes))\.(cs|vb)$",
                RegexOptions.IgnoreCase);
    }
}
