// This file originally obtained from 
// https://raw.githubusercontent.com/code-cracker/code-cracker/08c1a01337964924eeed12be8b14c8ce8ec6b626/src/Common/CodeCracker.Common/Extensions/GeneratedCodeAnalysisExtensions.cs
// It is subject to the Apache License 2.0
// This file has been modified since obtaining it from its original source.

namespace StyleCop.Analyzers
{
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Diagnostics;

    internal static class GeneratedCodeAnalysisExtensions
    {
        /// <summary>
        /// A cache of the result of computing whether a document has an auto-generated header.
        /// </summary>
        /// <remarks>
        /// This allows many analyzers that run on every token in the file to avoid checking
        /// the same state in the document repeatedly.
        /// </remarks>
        private static readonly ConditionalWeakTable<SyntaxTree, StrongBox<bool?>> GeneratedHeaderPresentCheck = new ConditionalWeakTable<SyntaxTree, StrongBox<bool?>>();

        internal static bool IsGenerated(this SyntaxNodeAnalysisContext context, CancellationToken cancellationToken) => (context.Node.SyntaxTree?.IsGenerated(cancellationToken) ?? false) || (context.Node?.IsGenerated() ?? false);

        internal static bool IsGenerated(this SyntaxTreeAnalysisContext context, CancellationToken cancellationToken) => context.Tree?.IsGenerated(cancellationToken) ?? false;

        internal static bool IsGenerated(this SymbolAnalysisContext context, CancellationToken cancellationToken)
        {
            if (context.Symbol == null) return false;
            foreach (var syntaxReference in context.Symbol.DeclaringSyntaxReferences)
            {
                if (syntaxReference.SyntaxTree.IsGenerated(cancellationToken)) return true;
                var root = syntaxReference.SyntaxTree.GetRoot(cancellationToken);
                var node = root?.FindNode(syntaxReference.Span);
                if (node.IsGenerated()) return true;
            }
            return false;
        }

        internal static bool IsGenerated(this SyntaxNode node) => node.HasAttributeOnAncestorOrSelf("DebuggerNonUserCode", "GeneratedCode");

        internal static bool IsGenerated(this SyntaxTree tree, CancellationToken cancellationToken) => (tree.FilePath?.IsOnGeneratedFile() ?? false) || tree.HasAutoGeneratedComment(cancellationToken);

        internal static bool HasAutoGeneratedComment(this SyntaxTree tree, CancellationToken cancellationToken)
        {
            StrongBox<bool?> cachedResult = GeneratedHeaderPresentCheck.GetOrCreateValue(tree);
            if (cachedResult.Value.HasValue)
            {
                return cachedResult.Value.Value;
            }

            var root = tree.GetRoot(cancellationToken);

            if (root == null) return false;
            var firstToken = root.GetFirstToken();
            SyntaxTriviaList trivia;
            if (firstToken == default(SyntaxToken))
            {
                var token = ((CompilationUnitSyntax)root).EndOfFileToken;
                if (!token.HasLeadingTrivia) return false;
                trivia = token.LeadingTrivia;
            }
            else
            {
                if (!firstToken.HasLeadingTrivia) return false;
                trivia = firstToken.LeadingTrivia;
            }

            var commentLines = trivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2).ToList();
            if (commentLines.Count != 2) return false;
            bool autoGenerated = commentLines[1].ToString() == "// <auto-generated>";

            // Update the strongbox's value with our computed result.
            // This doesn't change the strongbox reference, and its presence in the
            // ConditionalWeakTable is already assured, so we're updating in-place.
            // In the event of a race condition with another thread that set the value,
            // we'll just be re-setting it to the same value.
            cachedResult.Value = autoGenerated;

            return autoGenerated;
        }

        private static bool IsOnGeneratedFile(this string filePath) =>
            Regex.IsMatch(filePath, @"(^service|^TemporaryGeneratedFile_.*|^assemblyinfo|^assemblyattributes|\.(g\.i|g|designer|generated|assemblyattributes))\.(cs|vb)$",
                RegexOptions.IgnoreCase);
    }
}
