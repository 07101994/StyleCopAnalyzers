// This file originally obtained from 
// https://raw.githubusercontent.com/code-cracker/code-cracker/08c1a01337964924eeed12be8b14c8ce8ec6b626/src/Common/CodeCracker.Common/Extensions/GeneratedCodeAnalysisExtensions.cs
// It is subject to the Apache License 2.0
// This file has been modified since obtaining it from its original source.

namespace StyleCop.Analyzers
{
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Diagnostics;

    internal static class GeneratedCodeAnalysisExtensions
    {
        /// <summary>
        /// The value for a SyntaxTree in the <see cref="GeneratedHeaderPresentCheck"/> table
        /// when the document has an auto-generated header.
        /// </summary>
        private static readonly object GeneratedHeaderPresent = new object();

        /// <summary>
        /// The value for a SyntaxTree in the <see cref="GeneratedHeaderPresentCheck"/> table
        /// when the document does NOT have an auto-generated header.
        /// </summary>
        private static readonly object GeneratedHeaderAbsent = new object();

        /// <summary>
        /// A cache of the result of computing whether a document has an auto-generated header.
        /// </summary>
        /// <remarks>
        /// This allows many analyzers that run on every token in the file to avoid checking
        /// the same state in the document repeatedly.
        /// </remarks>
        private static readonly ConditionalWeakTable<SyntaxTree, object> GeneratedHeaderPresentCheck = new ConditionalWeakTable<SyntaxTree, object>();

        internal static bool IsGenerated(this SyntaxNodeAnalysisContext context, CancellationToken cancellationToken) => (context.Node.SyntaxTree?.IsGenerated(cancellationToken) ?? false) || (context.Node?.IsGenerated() ?? false);

        internal static bool IsGenerated(this SyntaxTreeAnalysisContext context, CancellationToken cancellationToken) => context.Tree?.IsGenerated(cancellationToken) ?? false;

        internal static bool IsGenerated(this SymbolAnalysisContext context, CancellationToken cancellationToken)
        {
            if (context.Symbol == null) return false;
            foreach (var syntaxReference in context.Symbol.DeclaringSyntaxReferences)
            {
                if (syntaxReference.SyntaxTree.IsGenerated(cancellationToken)) return true;
                var root = syntaxReference.SyntaxTree.GetRoot(cancellationToken);
                var node = root?.FindNode(syntaxReference.Span);
                if (node.IsGenerated()) return true;
            }
            return false;
        }

        internal static bool IsGenerated(this SyntaxNode node) => node.HasAttributeOnAncestorOrSelf("DebuggerNonUserCode", "GeneratedCode");

        internal static bool IsGenerated(this SyntaxTree tree, CancellationToken cancellationToken) => (tree.FilePath?.IsOnGeneratedFile() ?? false) || tree.HasAutoGeneratedComment(cancellationToken);

        internal static bool HasAutoGeneratedComment(this SyntaxTree tree, CancellationToken cancellationToken)
        {
            lock (GeneratedHeaderPresentCheck)
            {
                object previouslyDeterminedValue;
                if (GeneratedHeaderPresentCheck.TryGetValue(tree, out previouslyDeterminedValue))
                {
                    return previouslyDeterminedValue == GeneratedHeaderPresent;
                }
            }

            var root = tree.GetRoot(cancellationToken);

            if (root == null) return false;
            var firstToken = root.GetFirstToken();
            SyntaxTriviaList trivia;
            if (firstToken == default(SyntaxToken))
            {
                var token = ((CompilationUnitSyntax)root).EndOfFileToken;
                if (!token.HasLeadingTrivia) return false;
                trivia = token.LeadingTrivia;
            }
            else
            {
                if (!firstToken.HasLeadingTrivia) return false;
                trivia = firstToken.LeadingTrivia;
            }

            var commentLines = trivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2).ToList();
            if (commentLines.Count != 2) return false;
            bool autoGenerated = commentLines[1].ToString() == "// <auto-generated>";

            lock (GeneratedHeaderPresentCheck)
            {
                // We don't know if there was a race, and we want to avoid throwing,
                // so now that we have the lock, remove the key if it is already there.
                GeneratedHeaderPresentCheck.Remove(tree);
                GeneratedHeaderPresentCheck.Add(tree, autoGenerated ? GeneratedHeaderPresent : GeneratedHeaderAbsent);
            }

            return autoGenerated;
        }

        private static bool IsOnGeneratedFile(this string filePath) =>
            Regex.IsMatch(filePath, @"(^service|^TemporaryGeneratedFile_.*|^assemblyinfo|^assemblyattributes|\.(g\.i|g|designer|generated|assemblyattributes))\.(cs|vb)$",
                RegexOptions.IgnoreCase);
    }
}
